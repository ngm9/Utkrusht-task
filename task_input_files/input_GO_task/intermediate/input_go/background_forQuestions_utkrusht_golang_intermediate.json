{
    "organization": {
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "organization_name": "Utkrusht",
        "organization_background": "Utkrusht is a proof-of-skills marketplace that helps agile teams find talent with strong fundamental concepts with within days. We help aspiring professionals improve their profile with continuous improvement in their skills, documenting their journey and helping them fulfill their potential. We primarily build, conduct, proctor and disseminate proof-of-skill assessments in Technical domains like AI, ML, Fullstack development, High scale distributed systems, DevOps etc but do help non-tech roles like Sales, HR, Marketing etc" 
    },
  "role_context": "A Go engineer with 3–5 years of experience is expected to design, implement, and optimize concurrent systems and asynchronous workflows in production-grade Go applications. They should have strong command of goroutines, channels, synchronization primitives (`sync.WaitGroup`, `sync.Mutex`, `sync.Cond`, `sync.Once`), and Go’s `context` package for managing cancellation and timeouts. The engineer should independently handle concurrency-related performance tuning, prevent goroutine leaks, and ensure safe access to shared resources. They should be capable of designing multi-threaded pipelines, implementing worker pools, and optimizing parallelism for I/O or CPU-bound operations. The engineer should also demonstrate familiarity with Go’s runtime scheduler, profiling tools (`pprof`, `race` detector), and efficient memory usage patterns. While high-level architecture guidance may be provided, they are expected to deliver robust, maintainable, and high-performing concurrent applications.",

  "questions_prompt": "Please ensure the questions assess the candidate’s ability to apply Asynchronous and Multithreaded Programming patterns in Go effectively in real-world, performance-sensitive applications.\n\n- **Advanced Concurrency Design**: The candidate should demonstrate understanding of Go’s concurrency model, including how the Go scheduler handles M:N goroutine-to-thread mapping. They should explain when to use concurrency vs. parallelism and how to tune Go routines for throughput and responsiveness.\n\n- **Goroutines, Channels, and Synchronization**: The candidate should be able to design and implement concurrent workflows using goroutines and channels, including fan-in/fan-out, worker pool, and pipeline patterns. They should show proficiency in avoiding deadlocks, race conditions, and goroutine leaks through proper channel design and synchronization mechanisms.\n\n- **Context and Cancellation Handling**: The candidate should be able to integrate Go’s `context` package for graceful cancellation and timeouts in concurrent operations, particularly in API calls, background jobs, or long-running tasks.\n\n- **Error Handling and Coordination**: They should demonstrate structured error handling across multiple goroutines, aggregating results or failures, and ensuring proper cleanup when errors occur mid-execution. They should also understand how to combine channels, `select`, and synchronization primitives to coordinate multiple concurrent tasks.\n\n- **Performance and Debugging**: The candidate should know how to profile and benchmark concurrent code using Go’s tooling (`pprof`, `go test -bench`, `-race`). They should be able to identify bottlenecks such as excessive goroutines, blocking channels, or shared resource contention, and optimize accordingly.\n\nThe goal is to evaluate whether the candidate can build, optimize, and debug concurrent systems in Go that are both performant and reliable under load, leveraging Go’s concurrency primitives effectively and idiomatically."
    ,
    "yoe": "3-5"
}
