[
    {
        "competency_id": "7bb86559-abd3-45d6-bbd0-7827433efed7",
        "created_at": "2025-07-29T03:14:19.087072+00:00",
        "proficiency": "BASIC",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "Golang",
        "scope": "A go developer with BASIC proficiency in Golang, typically represents 1–3 years of experience, with the ability to build, run, and test small applications using core tools like `go build`, `go run`, and `go test`. They grasp language fundamentals (variables, loops, conditionals) and data structures (arrays, slices, maps), have a basic understanding of pointers, and use standard libraries (`fmt`, `strings`, `errors`, `net/http`) proficiently. Their concurrency skills involve goroutines and channels for simple parallel tasks, occasionally using `sync.WaitGroup`, though advanced patterns are beyond their comfort. They rely on `go.mod` and `go.sum` for dependency management, can integrate basic third-party libraries (e.g., Gin, Echo for HTTP routing, Logrus for logging), and format code with `gofmt` or `goimports`. They write unit tests using the `testing` package but may not be familiar with advanced mocking or coverage tools. They apply simple design principles, follow basic code organization practices, and can perform minimal debugging with logs or `fmt.Println`. Their error handling aligns with Go best practices (error returns, nil checks), and they might implement simple retry or fallback logic. They can handle basic CRUD operations using `database/sql` or a simple ORM, but lack deep knowledge of database performance tuning. Refactoring at this level is usually straightforward, and they may need guidance on complex architecture, high-performance optimization, or less-common frameworks. While they manage day-to-day tasks effectively, they typically look to more experienced colleagues for deeper architectural and concurrency decisions."
    }, 
    {
        "competency_id": "45cdd795-c65d-40f6-897c-885f6033b7ba",
        "created_at": "2025-07-29T03:14:19.087072+00:00",
        "proficiency": "BASIC",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "Docker",
        "scope": "A person with BASIC proficiency level in Docker as a competency should be able to explain OS-level virtualization vs. VMs/processes, outline Docker’s architecture (CLI, daemon, REST API, image store, registry, storage & network drivers) and relate images, containers, volumes, networks, namespaces, cgroups and capabilities. They author efficient Dockerfiles using FROM, RUN, COPY, ADD, WORKDIR, ENV, ARG, CMD, ENTRYPOINT, EXPOSE, USER, LABEL, VOLUME, HEALTHCHECK, STOPSIGNAL, ONBUILD, optimise layer order, respect .dockerignore and perform single- or simple multi-stage builds. They tag, re-tag, pull, push, sign and digest-verify images, inspect layers and reclaim space by pruning dangling artefacts. They run/start/stop/restart/kill/attach/remove containers with flags for ‑p, ‑v, ‑e, device access, restart policies, --memory, --cpus and ulimits. They cp files, tail logs, exec shells, enter PID namespace, inspect metadata/stats/events and select restart policies (always, on-failure, unless-stopped). They create/manage bind, anonymous and named volumes via local, NFS or cloud drivers, handle permissions and SELinux/AppArmor labels and contrast ephemeral vs. durable data. They configure default and user-defined bridge networks, host mode, port mapping, embedded DNS, know macvlan/overlay options and inspect or prune networks. Using docker-compose v2/v3 they define services, build contexts, depends_on, volumes, networks, env substitution, profiles/overrides and convert stacks to CLI for single-host orchestration. Security hygiene includes non-root USER, capability drop/add, resource limits, scanning with Docker Scout/Trivy, secure config.json credentials and secret management beyond plain ENV. Troubleshooting employs docker logs, systemd journal, docker events, exit codes, HEALTHCHECK, container stats, resolving port clashes, permission issues, DNS faults or cache invalidation and pruning safely. They integrate Docker into local dev with bind-mount live reload, automate CI build-tag-push-test via Makefile/scripts, document image contracts and know when to escalate advanced needs like multi-host orchestration, overlay networking, rootless mode or deep performance tuning."
    }
]