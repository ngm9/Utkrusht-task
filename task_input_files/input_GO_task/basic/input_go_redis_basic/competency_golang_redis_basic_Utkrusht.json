[
    {
        "competency_id": "7bb86559-abd3-45d6-bbd0-7827433efed7",
        "created_at": "2025-07-29T03:14:19.087072+00:00",
        "proficiency": "BASIC",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "Golang",
        "scope": "A go developer with BASIC proficiency in Golang, typically represents 1–3 years of experience, with the ability to build, run, and test small applications using core tools like `go build`, `go run`, and `go test`. They grasp language fundamentals (variables, loops, conditionals) and data structures (arrays, slices, maps), have a basic understanding of pointers, and use standard libraries (`fmt`, `strings`, `errors`, `net/http`) proficiently. Their concurrency skills involve goroutines and channels for simple parallel tasks, occasionally using `sync.WaitGroup`, though advanced patterns are beyond their comfort. They rely on `go.mod` and `go.sum` for dependency management, can integrate basic third-party libraries (e.g., Gin, Echo for HTTP routing, Logrus for logging), and format code with `gofmt` or `goimports`. They write unit tests using the `testing` package but may not be familiar with advanced mocking or coverage tools. They apply simple design principles, follow basic code organization practices, and can perform minimal debugging with logs or `fmt.Println`. Their error handling aligns with Go best practices (error returns, nil checks), and they might implement simple retry or fallback logic. They can handle basic CRUD operations using `database/sql` or a simple ORM, but lack deep knowledge of database performance tuning. Refactoring at this level is usually straightforward, and they may need guidance on complex architecture, high-performance optimization, or less-common frameworks. While they manage day-to-day tasks effectively, they typically look to more experienced colleagues for deeper architectural and concurrency decisions."
    }, 
    {
        "competency_id": "a0ead1b9-4a12-439c-94bb-815dea96683f",
        "created_at": "2025-07-29T03:14:19.087072+00:00",
        "proficiency": "BASIC",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "Redis",
        "scope": "A person with BASIC proficiency level in Redis as a competency should be able to describe Redis as an in-memory, single-threaded, event-driven store, differentiate RDB snapshots vs AOF persistence and explain TTL, expiration and eviction interactions on key lifecycle. They can choose the correct structure—strings, hashes, lists, sets, sorted sets, bitmaps, HyperLogLog or GEO—for a problem, knowing memory and complexity costs. They are fluent with redis-cli, pipelining, MULTI/EXEC, Lua EVAL, INFO, MONITOR, CONFIG, SLOWLOG and redis-benchmark for atomicity, introspection and load tests. They integrate Redis via Java, Python, Node.js, Go, C# clients, tune pools, timeouts, pipelining, and serialize with UTF-8, JSON, MessagePack or Protobuf. They configure RDB schedules, AOF fsync and rewrite thresholds, run backups, restores, cold-start recovery and estimate load times and disk growth. They deploy primary-replica with Sentinel, set quorum, monitor replication lag/backlog, validate failover handling and are aware of cluster mode without designing shards. They enforce AUTH/ACLs, rotate passwords, enable TLS, run behind firewalls or container namespaces and avoid default-port exposure. They export metrics to Prometheus, DataDog or cloud monitors, build Grafana dashboards and alert on memory fragmentation, ops/sec, latency, hit ratio and client buffers with documented runbooks. They diagnose performance via INFO, SLOWLOG, tweak maxmemory, eviction policy, batching and pipelines, escalating deeper issues appropriately. They script SCAN-based key audits, bulk deletions, TTL checks and plan capacity around key count, memory and network throughput. They model caching, sessions, leaderboards, rate limiting, token buckets, distributed locks, pub/sub fan-out and metadata enrichment while discussing consistency, durability and stale-data trade-offs. They keep current through docs, release notes, community advisories and sandbox trials of features or modules such as RedisSearch and RedisJSON, knowing when to escalate to senior engineers."
    }
]