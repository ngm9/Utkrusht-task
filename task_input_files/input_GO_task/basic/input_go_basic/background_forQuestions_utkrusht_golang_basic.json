{
    "organization": {
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "organization_name": "Utkrusht",
        "organization_background": "Utkrusht is a proof-of-skills marketplace that helps agile teams find talent with strong fundamental concepts with within days. We help aspiring professionals improve their profile with continuous improvement in their skills, documenting their journey and helping them fulfill their potential. We primarily build, conduct, proctor and disseminate proof-of-skill assessments in Technical domains like AI, ML, Fullstack development, High scale distributed systems, DevOps etc but do help non-tech roles like Sales, HR, Marketing etc" 
    },
  "role_context": "A software engineer with 1–2 years of experience in Go is expected to write small to medium features efficiently, following idiomatic Go design and concurrency principles. They should be comfortable building and running Go applications using `go build`, `go run`, and `go test`. The engineer should understand Go fundamentals — including slices, maps, structs, and interfaces — and apply these effectively when developing services or utilities. They should also have a foundational understanding of concurrency using goroutines and channels to manage lightweight parallel tasks, occasionally employing synchronization primitives such as `sync.WaitGroup` or `sync.Mutex`. Under the guidance of senior developers, they should be capable of implementing simple asynchronous workflows, handling basic race conditions, and ensuring proper resource cleanup. The engineer should be familiar with basic error handling, environment-based configuration, and logging using Go’s standard libraries.",

  "questions_prompt": "Please ensure the questions assess the candidate’s understanding of Asynchronous Programming and Multithreaded Programming in Go at a foundational level.\n\n- **Basic Concurrency and Parallelism Concepts**: The candidate should be able to explain the difference between concurrency and parallelism, and describe when to use goroutines for concurrent task execution. They should understand how Go’s scheduler manages lightweight threads and why goroutines are preferred for I/O-bound workloads.\n\n- **Goroutines and Channels**: The candidate should demonstrate basic proficiency in launching goroutines using the `go` keyword, using channels (buffered and unbuffered) for communication and synchronization, and avoiding common pitfalls like deadlocks and leaks. They should know how to properly close channels and synchronize multiple goroutines with `sync.WaitGroup`.\n\n- **Synchronization and Thread Safety**: The candidate should show an understanding of simple synchronization tools like `sync.Mutex` for mutual exclusion, and know how to detect race conditions using Go’s `-race` flag. They should be able to identify unsafe shared memory access patterns and suggest ways to fix them.\n\n- **Asynchronous Task Management**: The candidate should know how to coordinate simple background operations asynchronously using goroutines and channels — for example, fetching data from multiple sources concurrently or processing a batch of messages without blocking the main thread. They should also demonstrate awareness of using the `select` statement for multiplexing channel operations.\n\n- **Error Handling and Performance Awareness**: The candidate should understand how to propagate errors through channels or shared variables and avoid blocking or excessive goroutines. They should be aware of efficient goroutine usage and how poor synchronization can lead to performance degradation.\n\nThe goal is to evaluate whether the candidate can safely and effectively implement simple asynchronous and concurrent logic in Go while following idiomatic and maintainable coding practices.",
    "yoe": "1-2"
}
