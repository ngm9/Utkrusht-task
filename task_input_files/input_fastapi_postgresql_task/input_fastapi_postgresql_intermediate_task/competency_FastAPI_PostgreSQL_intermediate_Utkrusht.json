[
    {
        "competency_id": "c33b6450-5b6b-468d-ad66-4348bd911496",
        "created_at": "2025-03-31T05:05:21.227830+00:00",
        "proficiency": "INTERMEDIATE",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "Python - FastAPI",
        "scope": "A person with INTERMEDIATE proficiency level in Python FastAPI as a competency should be able to / is capable of planning, structuring, and maintaining moderately complex APIs that use routers for route organization and advanced data modeling/validation with Pydantic’s validators and custom data types. They handle async/await patterns, concurrency, and performance tuning, recognizing blocking operations or bottlenecks and offloading secondary tasks with background jobs. They design secure endpoints through solid authentication/authorization techniques (OAuth2, role-based access), implement best practices for token handling, and appreciate further security concerns (CSRF, XSS). They manage database interactions through SQLAlchemy or equivalent ORMs, ensuring transactional integrity, handling schema migrations, and optimizing queries when needed. They write robust tests and integrate Pytest or similar frameworks with FastAPI-specific dependency overrides, ensuring maintainable and isolated testing. They containerize and deploy applications with Docker, manage environment-based configurations, and incorporate structured logging plus monitoring (Prometheus, Grafana) for production readiness. They centralize error management with custom exception handlers and consistent error payloads, employing protective patterns like retries, rate-limiting, or circuit breakers, and handle advanced middleware usage. They produce usable OpenAPI-based interactive documentation, refining schema tags and metadata as the codebase evolves. They understand message queue integrations (RabbitMQ, Kafka), caching with Redis, and basic microservice or SOA concepts, though not at a deep architectural level. They collaborate effectively in code reviews, mentor junior developers, maintain consistent code quality, and prepare to step into deeper concurrency, scalability, and performance exploration toward advanced levels."
    
    },
    {
        "competency_id": "8b53570d-2be9-4bd6-8493-2d29cca76990",
        "created_at": "2025-03-31T05:05:21.227830+00:00",
        "proficiency": "INTERMEDIATE",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "PostgreSQL",
        "scope": "A person with INTERMEDIATE proficiency level in PostgreSQL as a competency should be able to / is capable of grasping core architecture—postmaster vs. backend processes, shared_buffers, work_mem, maintenance_work_mem, temp_buffers, WAL flow (pg_wal, pg_current_wal_lsn, pg_walfile_name), checkpoints, background writer, autovacuum, MVCC visibility, HOT updates, freezing, hint bits—and exploit views/tools like pg_stat_activity, pg_stat_bgwriter, pg_stat_wal, pg_file_settings and log_line_prefix. They build schemas in 1-5NF with surrogate/natural/composite keys, inheritance, declarative partitioning (RANGE/LIST/HASH, sub-partitions, global/local indexes), tablespaces, domains, enums, collations, JSONB, arrays and range types, documenting via ERDs and versioning with Liquibase, Flyway or Sqitch. They craft SQL using CTEs (materialised and inline), window functions, set ops, LATERAL, FILTER aggregates, INSERT … ON CONFLICT, generated/identity columns, COPY, and FDWs (postgres_fdw, file_fdw, mysql_fdw, jdbc_fdw) while leaning on psql, pgAdmin, DBeaver, pgFormatter and pgsql-lint. They write PL/pgSQL with exceptions, security DEFINER/INVOKER, statement-/row-level triggers, transition tables, LISTEN/NOTIFY, basic logical decoding via pgoutput, debug with pldbgapi and auto_explain, and extend with plpython3u. They design B-tree, GIN, GiST, BRIN, hash, expression, partial and covering indexes, decode EXPLAIN ANALYZE BUFFERS VERBOSE, understand bitmap vs. index-only scans, page splits, visibility map and bloat, and maintain with VACUUM (INDEX_CLEANUP), autovacuum tuning, REINDEX CONCURRENTLY, pg_stat_statements and pg_waldump. They handle transactions and concurrency—ACID snapshots, READ COMMITTED/REPEATABLE READ/SERIALIZABLE, advisory locks, SKIP LOCKED, NOWAIT—resolve deadlocks via pg_locks and blocking_pids, and use pg_cancel_backend or pg_terminate_backend safely. They tune performance by adjusting shared_buffers, effective_cache_size, work_mem, maintenance_work_mem, max_parallel_workers_per_gather, wal_compression, planner cost constants and enable_* flags, leverage parallel query, pg_stat_all_tables, pg_stat_io, pg_stat_kcache, pgbench, pgBadger, pg_stat_monitor, auto_explain, iostat, vmstat and perf, plus optimise I/O layout, FILLFACTOR and autovacuum_freeze_max_age. They secure dependable backups with pg_dump/pg_dumpall, pg_basebackup, compression/encryption, WAL archiving, restore_command, recovery_target_time, PITR, pg_amcheck, CHECKPOINT control, schedule via cron/pg_cron, and use pgBackRest, Barman, WAL-G, pg_repack and pg_partman. They deploy streaming replication with synchronous_commit, physical/logical slots, analyse lag, manage hot_standby_feedback and max_standby_streaming_delay, run pg_basebackup --write-recovery-conf and pg_ctl promote, orchestrate failovers with repmgr, Patroni or pg_auto_failover, and prototype logical flows with pg_logical or test_decoding. They enforce security through role hierarchies, hardened search_path, row-level security, SSL/TLS, client-cert, SCRAM-SHA-256, pg_hba.conf, logging_collector, log_statement, pgaudit and pgcrypto. They evaluate and manage extensions (uuid-ossp, hstore, citext, pg_trgm, PostGIS, auth_delay, pg_stat_statements), integrate with Hibernate, SQLAlchemy, Django ORM via PgBouncer (transaction/session), package with Docker official images, CrunchyData/Zalando operators, Ansible, Helm, Terraform, monitor in Prometheus + Grafana, run CI/CD migrations with Git, feature flags and shadow tables, and handle incidents through PagerDuty or OpsGenie."
        
    }
]