[ {
        "competency_id": "49fd3df2-abdc-4a7b-9d2b-5bc02d8e29e6",
        "created_at": "2025-03-31T05:05:21.227830+00:00",
        "proficiency": "BASIC",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "PostgreSQL",
        "scope": "A person with INTERMEDIATE proficiency level in PostgreSQL as a competency should be able to / is capable of grasping core architecture—postmaster vs. backend processes, shared_buffers, work_mem, maintenance_work_mem, temp_buffers, WAL flow (pg_wal, pg_current_wal_lsn, pg_walfile_name), checkpoints, background writer, autovacuum, MVCC visibility, HOT updates, freezing, hint bits—and exploit views/tools like pg_stat_activity, pg_stat_bgwriter, pg_stat_wal, pg_file_settings and log_line_prefix. They build schemas in 1-5NF with surrogate/natural/composite keys, inheritance, declarative partitioning (RANGE/LIST/HASH, sub-partitions, global/local indexes), tablespaces, domains, enums, collations, JSONB, arrays and range types, documenting via ERDs and versioning with Liquibase, Flyway or Sqitch. They craft SQL using CTEs (materialised and inline), window functions, set ops, LATERAL, FILTER aggregates, INSERT … ON CONFLICT, generated/identity columns, COPY, and FDWs (postgres_fdw, file_fdw, mysql_fdw, jdbc_fdw) while leaning on psql, pgAdmin, DBeaver, pgFormatter and pgsql-lint. They write PL/pgSQL with exceptions, security DEFINER/INVOKER, statement-/row-level triggers, transition tables, LISTEN/NOTIFY, basic logical decoding via pgoutput, debug with pldbgapi and auto_explain, and extend with plpython3u. They design B-tree, GIN, GiST, BRIN, hash, expression, partial and covering indexes, decode EXPLAIN ANALYZE BUFFERS VERBOSE, understand bitmap vs. index-only scans, page splits, visibility map and bloat, and maintain with VACUUM (INDEX_CLEANUP), autovacuum tuning, REINDEX CONCURRENTLY, pg_stat_statements and pg_waldump. They handle transactions and concurrency—ACID snapshots, READ COMMITTED/REPEATABLE READ/SERIALIZABLE, advisory locks, SKIP LOCKED, NOWAIT—resolve deadlocks via pg_locks and blocking_pids, and use pg_cancel_backend or pg_terminate_backend safely. They tune performance by adjusting shared_buffers, effective_cache_size, work_mem, maintenance_work_mem, max_parallel_workers_per_gather, wal_compression, planner cost constants and enable_* flags, leverage parallel query, pg_stat_all_tables, pg_stat_io, pg_stat_kcache, pgbench, pgBadger, pg_stat_monitor, auto_explain, iostat, vmstat and perf, plus optimise I/O layout, FILLFACTOR and autovacuum_freeze_max_age. They secure dependable backups with pg_dump/pg_dumpall, pg_basebackup, compression/encryption, WAL archiving, restore_command, recovery_target_time, PITR, pg_amcheck, CHECKPOINT control, schedule via cron/pg_cron, and use pgBackRest, Barman, WAL-G, pg_repack and pg_partman. They deploy streaming replication with synchronous_commit, physical/logical slots, analyse lag, manage hot_standby_feedback and max_standby_streaming_delay, run pg_basebackup --write-recovery-conf and pg_ctl promote, orchestrate failovers with repmgr, Patroni or pg_auto_failover, and prototype logical flows with pg_logical or test_decoding. They enforce security through role hierarchies, hardened search_path, row-level security, SSL/TLS, client-cert, SCRAM-SHA-256, pg_hba.conf, logging_collector, log_statement, pgaudit and pgcrypto. They evaluate and manage extensions (uuid-ossp, hstore, citext, pg_trgm, PostGIS, auth_delay, pg_stat_statements), integrate with Hibernate, SQLAlchemy, Django ORM via PgBouncer (transaction/session), package with Docker official images, CrunchyData/Zalando operators, Ansible, Helm, Terraform, monitor in Prometheus + Grafana, run CI/CD migrations with Git, feature flags and shadow tables, and handle incidents through PagerDuty or OpsGenie."
        }
]