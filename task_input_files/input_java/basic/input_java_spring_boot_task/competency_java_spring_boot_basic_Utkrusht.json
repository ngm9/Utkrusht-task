[
    {
        "competency_id": "c9bd828d-58c2-4377-9ea7-be5044ecc284",
        "created_at": "2025-07-29T03:14:19.087072+00:00",
        "proficiency": "BASIC",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "Java",
        "scope": "A person with BASIC proficiency level in Java as a competency should be able to understand the Java execution model (JDK, JRE, JVM) and write maintainable code using proper packages and naming conventions. They possess foundational proficiency in Java syntax, including control flow, error handling, and basic class structures. Their knowledge of OOP principles (Encapsulation, Inheritance, Polymorphism, Abstraction) allows them to create coherent classes with appropriate access modifiers. They are comfortable employing Java’s core collections (List, Set, Map), grasping performance impacts of ArrayList vs LinkedList and HashMap vs TreeMap. They handle exceptions using try-catch-finally and appreciate the difference between checked and unchecked exceptions. Their concurrency awareness extends to creating and running simple threads, with a limited understanding of race conditions and synchronization. They can effectively use IDEs (e.g., IntelliJ, Eclipse), basic build tools (Maven, Gradle), and version control (Git) for daily tasks and collaboration. They have exposure to simple frameworks or libraries like JDBC for database connectivity, JUnit for testing, and minimal Spring Boot configurations. They follow introductory best practices such as organizing code, avoiding duplication, and adhering to naming standards, with an initial grasp of SOLID principles. They can debug code using IDE breakpoints, write straightforward test cases, and refactor small code snippets to address performance or readability concerns. They have participated in at least one small Java project, handled feature development, bug fixes, and engaged in code reviews. Their approach to software development involves basic Agile or similar methodologies, ensuring they can communicate effectively within a team."
    },
     {
        "competency_id": "875c0b98-e76e-40b9-b595-c3633afbd6c6",
        "created_at": "2025-07-29T03:14:19.087072+00:00",
        "proficiency": "BASIC",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "Java - Spring Boot",
        "scope": "A person with BASIC proficiency level in Spring Boot with Java as a competency should be able to / is capable of scaffolding a project with Spring Initializr, running it via embedded Tomcat/Jetty/Undertow, managing application.yml/properties, profiles, and overriding auto-configuration through Maven or Gradle plugins. They understand and apply the IoC container, component scanning, @Component/@Service/@Repository/@Configuration/@Bean, singleton/prototype/request scopes, constructor injection and basic bean life-cycle callbacks. They possess solid Java 8+ fundamentals—OOP, interfaces, generics, collections, streams, optionals, lambdas, annotations, reflection basics, exception hierarchy, synchronized/volatile/executor services and a conceptual grasp of the JVM memory model. They build REST APIs with Spring MVC (@RestController, @RequestMapping, @Get/@Post/@Put/@DeleteMapping, @PathVariable, @RequestParam, @RequestBody), perform JSON/XML conversion via Jackson, validate with JSR-380 @Valid/@Validated, handle CORS, and create global error handlers via @ControllerAdvice/ResponseEntity. They persist data using Spring Data JPA on H2/MySQL/PostgreSQL, define entities and relationships, leverage CrudRepository/JpaRepository, derived queries, @Query JPQL/native SQL, pagination, sorting, @Transactional, and run Flyway/Liquibase migrations. They test with JUnit 5, Mockito, @SpringBootTest, @WebMvcTest, @DataJpaTest, TestEntityManager, MockMvc, TestRestTemplate, and produce Jacoco coverage in CI. They secure endpoints using Spring Security starter with HTTP Basic or form login, CSRF, path-based authorization, in-memory/JDBC user stores, password encoders, method-level security and understand filter-chain order. They configure SLF4J/Logback logging, adjust levels/patterns, enable DevTools reload, expose Actuator health/metrics/env/log endpoints and diagnose issues with debug logs. They package executable fat JARs, craft Dockerfiles, externalize configuration via environment variables/volumes, and respect health/readiness probes and graceful shutdown in containers. They use IntelliJ/Eclipse/VS Code with Spring & Lombok plugins, generate API docs with SpringDoc OpenAPI/Swagger UI, manage code in Git (branching, merging, pull requests), conduct reviews, follow style guides, run SpotBugs/PMD/SonarLint/SonarQube and maintain READMEs and release notes. They articulate layered architecture (controller–service–repository–domain), SOLID/dependency-inversion, basic monolith vs microservice trade-offs, spot N+1 queries and tweak connection pools or JVM options for simple performance wins. They follow twelve-factor config, keep secrets out of VCS, and select OSS libraries with compatible licenses."
    }

]