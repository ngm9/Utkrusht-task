[
    {
        "competency_id": "4d7392b0-b805-4852-bdf6-f04b73b757f9",
        "created_at": "2025-07-29T03:14:19.087072+00:00",
        "proficiency": "INTERMEDIATE",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "Java",
        "scope": "A person with INTERMEDIATE proficiency level in Java as a competency should be able to / is capable of writing and debugging production-ready applications using core Java constructs (loops, conditionals, generics, annotations, Collections Framework) while applying OOP principles (inheritance, polymorphism, encapsulation, abstraction). They demonstrate moderate concurrency skills (Threads, Runnables, Executors) with a basic grasp of the Java Memory Model, follow SOLID principles to avoid code smells, and effectively use frameworks like Spring (Spring Boot, MVC, Data) or Jakarta EE for building web applications, REST APIs, and microservices, integrating common logging (SLF4J, Log4j) and security (Spring Security). They employ ORM libraries (JPA/Hibernate) to map entities to relational databases (MySQL, PostgreSQL, Oracle) with an understanding of eager vs. lazy loading and manage environment-based configurations using build tools like Maven and Gradle. They containerize applications with Docker, have some exposure to cloud providers (AWS, GCP, Azure), and set up CI/CD pipelines (Jenkins, GitLab CI, GitHub Actions) for automated builds, tests, and deployments. They write unit and integration tests (JUnit, TestNG) with mocking (Mockito), measure coverage with Jacoco or SonarQube, and practice basic TDD or BDD if required. They troubleshoot performance issues using profiling tools (VisualVM, JDK Mission Control, YourKit), refine inefficient queries, and optimize concurrency and data structures. They address fundamental security concerns (parameterized queries, handling secrets), apply microservices concepts (service discovery, circuit breakers), and incorporate resilience patterns. They also adopt relevant design patterns (Singleton, Factory, Strategy, Observer), use diagramming tools (UML, PlantUML) for architecture visualization, and collaborate through code reviews and documentation (Confluence, GitHub Wiki). Overall, they consistently deliver maintainable, high-quality Java solutions suitable for enterprise projects, while guiding junior developers on best practices and ensuring solid team communication."
    },
    {
        "competency_id": "6f289c2a-db97-4e07-a6e9-a3b7cb84e6f0",
        "created_at": "2025-07-29T03:14:19.087072+00:00",
        "proficiency": "INTERMEDIATE",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "Java - Spring Boot",
        "scope": "A person with INTERMEDIATE proficiency level in Java - Spring Boot as a competency should be able to design, code and deploy complete, production-ready microservices with limited supervision, following SOLID, clean/hexagonal architecture and basic DDD concepts while communicating trade-offs. They master Java 11-17 language features (generics, lambdas/streams, Optional, records, try-with-resources, switch expressions), core APIs (Collections, NIO2, serialization), java.util.concurrent & CompletableFuture, basic JVM internals (class-loading, GC types, JIT) and can profile with JFR/VisualVM/async-profiler. They understand Spring IoC/DI, bean scopes & lifecycle, @Configuration/@Bean/@Component, application events, AOP with pointcuts, and Bean-Validation. They exploit Spring Boot starters, auto-configuration & @ConditionalOn*, externalised configuration hierarchy, @ConfigurationProperties, profiles, Actuator (health, metrics, env, custom indicators) and structured Logback/SLF4J logging with MDC. They build robust REST APIs using Spring MVC @RestController, request mapping, content negotiation, versioning, validation, @ControllerAdvice error handling, Jackson custom serializers, async endpoints (Callable/DeferredResult) and document with Springdoc-OpenAPI/Swagger, with basic WebFlux awareness. They persist data via Spring Data JPA (entity mapping, @Query, Specifications, pagination), manage transactions (@Transactional propagation/isolation), optimise with fetch strategies & HikariCP, use JdbcTemplate when needed, integrate MongoDB & Redis repositories, version schemas via Flyway/Liquibase and implement Spring Cache with caffeine/redis. They secure services through Spring Security filter-chain, JWT/OAuth2 resource server, AuthenticationManager customisation, method-level @PreAuthorize, CSRF/CORS and test with spring-security-test. They manage builds with Maven/Gradle (multi-module, BOMs, plugins, enforcer), handle dependency mediation, publish to Nexus/Artifactory, and test using JUnit 5, Mockito, Spring Boot test-slices, Testcontainers, WireMock and Spring Cloud Contract with coverage via JaCoCo/Sonar. They integrate externally via RestTemplate/WebClient, OpenFeign, Kafka/RabbitMQ (Spring Kafka/AMQP), apply Resilience4j patterns (circuit-breaker, retry, bulkhead), consume Spring Cloud Config and understand Eureka/Kubernetes service discovery. They containerise with multi-stage Dockerfiles, tune JVM layers, craft Kubernetes/Helm manifests with liveness/readiness probes, deploy to AWS ECS/Fargate or Azure AppService, manage secrets, and leverage centralised logging/metrics. They implement observability through Micrometerâ†’Prometheus, custom meters, Spring Cloud Sleuth/OpenTelemetry tracing to Zipkin/Jaeger, ELK/Loki stacks, correlation IDs, dashboards in Grafana and perform live debugging with thread/heap dumps and flame graphs. Finally, they collaborate via advanced Git (rebase, bisect), write CI/CD pipelines in Jenkins/GitLab CI/GitHub Actions (build, test, scan, containerise, deploy), apply static/security analysis (SpotBugs, PMD, OWASP-Dependency-Check/Snyk), orchestrate canary/dark launches, diagnose incidents, and mentor juniors while deferring large-scale architectural decisions to senior staff."
    }

]