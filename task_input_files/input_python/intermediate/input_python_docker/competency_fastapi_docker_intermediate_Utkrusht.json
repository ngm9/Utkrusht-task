[{
        "competency_id": "c33b6450-5b6b-468d-ad66-4348bd911496",
        "created_at": "2025-03-31T05:05:21.227830+00:00",
        "proficiency": "INTERMEDIATE",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "Python - FastAPI",
        "scope": "A person with INTERMEDIATE proficiency level in Python FastAPI as a competency should be able to / is capable of planning, structuring, and maintaining moderately complex APIs that use routers for route organization and advanced data modeling/validation with Pydanticâ€™s validators and custom data types. They handle async/await patterns, concurrency, and performance tuning, recognizing blocking operations or bottlenecks and offloading secondary tasks with background jobs. They design secure endpoints through solid authentication/authorization techniques (OAuth2, role-based access), implement best practices for token handling, and appreciate further security concerns (CSRF, XSS). They manage database interactions through SQLAlchemy or equivalent ORMs, ensuring transactional integrity, handling schema migrations, and optimizing queries when needed. They write robust tests and integrate Pytest or similar frameworks with FastAPI-specific dependency overrides, ensuring maintainable and isolated testing. They containerize and deploy applications with Docker, manage environment-based configurations, and incorporate structured logging plus monitoring (Prometheus, Grafana) for production readiness. They centralize error management with custom exception handlers and consistent error payloads, employing protective patterns like retries, rate-limiting, or circuit breakers, and handle advanced middleware usage. They produce usable OpenAPI-based interactive documentation, refining schema tags and metadata as the codebase evolves. They understand message queue integrations (RabbitMQ, Kafka), caching with Redis, and basic microservice or SOA concepts, though not at a deep architectural level. They collaborate effectively in code reviews, mentor junior developers, maintain consistent code quality, and prepare to step into deeper concurrency, scalability, and performance exploration toward advanced levels."
    
    },
    {
        "competency_id": "769a5bf7-352d-4ac3-acc1-a886585658b6",
        "created_at": "2025-07-29T03:14:19.087072+00:00",
        "proficiency": "INTERMEDIATE",
        "organization_id": "bfbd7da3-a43b-47dc-b828-146733b5c81e",
        "name": "Redis",   
        "scope": "A person with INTERMEDIATE proficiency level in Redis as a competency should be able to design and maintain a coherent key-space with naming, TTL and eviction strategy, select and combine all core data types (String, List, Hash, Set, Sorted Set, HyperLogLog, Bitmap, Stream, Geo) while using Lua, MULTI/EXEC, WATCH and PIPELINE for atomic, batched, optimistic workflows and accurately sizing memory. They configure RDB, AOF and hybrid persistence, tune appendfsync and rewrite thresholds, automate backup, restore, point-in-time recovery and execute zero-data-loss upgrades or migrations. They deploy and run Sentinel with correct quorum, down-after-milliseconds and failover-timeout, analyse pub/sub channels to avoid split-brain and perform manual or automatic role switches. They provision and reshard Redis Cluster, assign hash-slots, grow or shrink nodes, determine shard count and replication factor and tune client smart-routing and slot cache refresh. They benchmark with redis-benchmark or k6, inspect INFO, SLOWLOG, MONITOR, LATENCY DOCTOR, then adjust maxmemory, active-defrag, hz, io-threads, client-output-buffers and TCP settings to hit p-99 latency targets. They integrate Prometheus or StatsD exporters, create Grafana dashboards, use RedisInsight or CLI-perf tools, and alert on replication offset, evictions, rejected connections and command distribution. They harden security through AUTH, ACLs, SSL/TLS, protected-mode, command renaming, disabling CONFIG, secret rotation and least-privilege role mapping. They embed Redis in micro-services for read-through/write-through/lazy-invalidate caching, implement distributed locks, rate limiting, leader election, task queues, Pub/Sub and Streams consumer groups with back-pressure and fencing tokens, and tune pools, retries and circuit breakers in Java, .NET, Python, Go, NodeJS and Rust clients. They execute rolling restarts, CONFIG REWRITE, online memory rescale, patch/minor upgrades via Terraform, Ansible, Helm or CloudFormation modules in Docker/Kubernetes pipelines and maintain comprehensive runbooks. They troubleshoot latency spikes, failovers and memory leaks by correlating client telemetry, server logs and OS metrics, replicate issues with custom redis-server configs and produce post-mortems and capacity plans. Finally, they evaluate and integrate modules such as Bloom, JSON, TimeSeries, Search and Graph, understand single-threaded execution, big-O per command, replication lag and consistency windows, and articulate trade-offs versus alternative stores."
    }
  
]